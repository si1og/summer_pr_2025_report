\subsection{Тестирование и компиляция библиотеки поиска максимального элемента}

Для проверки корректности работы библиотеки поиска максимального элемента был создан каталог \texttt{tests}, в котором размещён файл \texttt{test.c}. 
На скриншоте~\ref{fig:Screenshot_2025-06-30_at_07.47.15.png} показан процесс редактирования данного файла в редакторе \texttt{nano}.

\screenshot{Screenshot_2025-06-30_at_07.47.15.png}{Редактирование файла test.c в nano}

\vspace{0.5cm}
\noindent
Ниже приводится краткое описание функций, использованных в тестовой программе:

\begin{itemize}
  \item \texttt{int myrand()} — простая реализация генератора псевдослучайных чисел. Использует фиксированный \texttt{seed}, что позволяет при каждом запуске получать одну и ту же последовательность случайных чисел. Это важно для корректного сравнения времени работы функций, так как они получают одинаковые данные на вход.

\item \texttt{double measure(int (*func)(const int*, int), const int* arr, int size)} — функция измерения времени выполнения. Принимает указатель на функцию поиска максимума (\texttt{max\_iterative} или \texttt{max\_recursive}), массив и его размер. 
\begin{itemize}
    \item С помощью \texttt{gettimeofday} замеряется время до и после вызова функции поиска максимального элемента.
    \item Вычисляется затраченное время в миллисекундах, выводится результат (максимальный элемент) и это время на экран.
    \item Возвращает затраченное время в качестве значения типа \texttt{double}.
\end{itemize}

\item \texttt{int main()} — главная функция тестовой программы. 
  \begin{itemize}
      \item Создаёт массив из $100\,000$ случайных целых чисел с помощью функции \texttt{myrand}.
      \item Поочерёдно вызывает функцию \texttt{measure} для двух вариантов поиска максимального элемента: \texttt{max\_iterative} и \texttt{max\_recursive}.
      \item Таким образом, обеспечивает единообразное тестирование и вывод времени работы обоих алгоритмов на одном и том же массиве.
  \end{itemize}
\end{itemize}

\vspace{0.3cm}
\noindent\textbf{Замечание.} Тестирование было проведено только для типа \texttt{int}, так как написание отдельных тестовых программ для типов \texttt{char} и \texttt{double} не представлялось целесообразным — проверка общих свойств алгоритмов (итеративности и рекурсии) и их времени работы в достаточной степени демонстрируется на примере целых чисел.

\subsubsection{Сборка статической и динамической библиотек}

Для автоматизации процесса компиляции и линковки проекта был создан скрипт \texttt{CMakeLists.txt}, который редактировался в редакторе \texttt{nano}, что подтверждается на скриншоте ниже.

\screenshot{Screenshot_2025-06-30_at_15.05.26.png}{Редактирование файла CMakeLists.txt в редакторе nano}

\vspace{0.5em}
В этом скрипте задаётся сборка библиотеки поиска максимального элемента в двух вариантах:
\begin{itemize}
\item \textbf{Статическая библиотека} (\texttt{libmax.a}), собираемая через:
\begin{lstlisting}
add_library(max_static STATIC ${MAX_SRC} ${MAX_HDR})
\end{lstlisting}
\item \textbf{Динамическая библиотека} (\texttt{libmax.so}), через:
\begin{lstlisting}
add_library(max_shared SHARED ${MAX_SRC} ${MAX_HDR})
\end{lstlisting}
\end{itemize}

Также описываются два исполняемых файла для тестирования этих библиотек:
\begin{itemize}
\item \texttt{test\_static} — программа, линкующаяся со статической версией библиотеки;
\item \texttt{test\_dynamic} — программа для динамической линковки.
\end{itemize}

Дополнительно используется установка свойств \texttt{BUILD\_RPATH} и \texttt{INSTALL\_RPATH} для \texttt{test\_dynamic}, чтобы исполняемый файл мог находить \texttt{libmax.so} в той же папке без дополнительных переменных окружения.

\vspace{0.5em}
После подготовки \texttt{CMakeLists.txt} проект собирался следующими командами:
\begin{lstlisting}
mkdir build
cd build
cmake ..
make
\end{lstlisting}
На скриншоте ниже показан процесс сборки с помощью \texttt{CMake} и \texttt{Make}:

\screenshot{Screenshot_2025-06-30_at_15.21.29.png}{Процесс сборки проекта с созданием библиотек и исполняемых файлов}

\vspace{0.5em}
В результате в каталоге \texttt{build} появились файлы:
\begin{itemize}
\item \texttt{libmax.a} — статическая библиотека;
\item \texttt{libmax.so} — динамическая библиотека;
\item \texttt{test\_static} — программа для теста со статической линковкой;
\item \texttt{test\_dynamic} — программа для теста с динамической линковкой.
\end{itemize}

\paragraph{Флаг компиляции}
Сборка происходила с использованием уровня оптимизации по умолчанию для CMake. На представленном скриншоте \texttt{CMakeLists.txt} отсутствует явный флаг \texttt{-O2}, значит компиляция прошла с флагом по умолчанию (обычно \texttt{-O0} или \texttt{-O2} в зависимости от предустановок CMake/компилятора).

Более подробно влияние флагов компиляции будет рассматриваться в следующем пункте.

\vspace{0.5em}
\paragraph{Тестирование}
На следующем скриншоте показан запуск тестовых программ и вывод времени работы для статической и динамической версий:

\screenshot{Screenshot_2025-06-30_at_15.23.01.png}{Результаты запуска программ test\_dynamic и test\_static}

Видно, что для обоих случаев итеративная версия поиска максимального элемента работает значительно быстрее рекурсивной. При этом результаты одинаковы, что подтверждает корректность реализации.

\subsubsection{Сборка с различными флагами оптимизации}

Для исследования влияния оптимизаций компилятора на производительность программы был составлен скрипт \texttt{test.bash}, представленный на скриншоте \ref{fig:Screenshot_2025-06-30_at_16.11.23.png} (редактирование производилось в редакторе \texttt{nano}):

\screenshot{Screenshot_2025-06-30_at_16.11.23.png}{Скрипт test.bash для многократной сборки с разными флагами оптимизации}

\noindent Этот скрипт автоматизирует процесс конфигурации и сборки проекта с различными значениями флага \texttt{-O}, проходя по ним в цикле:
\begin{lstlisting}[language=bash]
for opt in O0 O1 O2 O3 Os
do
echo "=== Building with -$opt ==="
cmake -DCMAKE_C_FLAGS="-$opt" -B build_$opt
cmake --build build_$opt
done
\end{lstlisting}

\noindent В результате для каждого уровня оптимизации создаётся отдельный каталог (\texttt{build\_O0}, \texttt{build\_O1} и т.д.), где собираются две версии программы: со статической и динамической линковкой.

На следующих скриншотах показан вывод выполнения скрипта и запуск тестов для каждого уровня оптимизации:

\screenshot{Screenshot_2025-06-30_at_16.05.46.png}{Запуск тестов для статической и динамической линковки с \texttt{-O0} и \texttt{-O1}}

\screenshot{Screenshot_2025-06-30_at_16.06.23.png}{Запуск тестов для  \texttt{-O2}, \texttt{-O3}}

\screenshot{Screenshot_2025-06-30_at_16.07.15.png}{Запуск тестов для \texttt{-Os}}

\subsubsection{Оптимизация компиляции и её влияние}

\begin{itemize}
    \item \texttt{-O0} — оптимизации отключены. Компилятор генерирует максимально «прямолинейный» и понятный код, близкий к исходному, что упрощает отладку, но замедляет исполнение.
    \item \texttt{-O1} — базовые оптимизации. Производятся простые преобразования кода для уменьшения размера и ускорения выполнения.
    \item \texttt{-O2} — более агрессивные оптимизации, включая развёртывание циклов, устранение мёртвого кода и др. Обычно используется по умолчанию для сборки релизов.
    \item \texttt{-O3} — включает все оптимизации \texttt{-O2} плюс дополнительные агрессивные, что может ускорить некоторые программы, но иногда приводит к большему размеру бинарного файла и непредсказуемым побочным эффектам.
    \item \texttt{-Os} — особый режим, при котором компилятор старается уменьшить размер исполняемого файла, при этом сохраняя большую часть оптимизаций \texttt{-O2}.
\end{itemize}

\paragraph*{Анализ экспериментов}

Из результатов, представленных на скриншотах выше, видно явное влияние уровня оптимизации на время работы функций:

\begin{itemize}
    \item Для \texttt{-O0} (без оптимизаций) рекурсивная функция работала значительно медленнее (около 12--13 мс), тогда как итеративная занимала около $0.3$ мс. Это объясняется отсутствием каких-либо преобразований кода и значительными накладными расходами на рекурсивные вызовы.
    
    \item Для \texttt{-O1} и \texttt{-O2} время выполнения рекурсивной версии заметно сократилось до $2$--$4$ мс, а итеративная снизилась до $\approx 0.05$--$0.1$ мс.
    
    \item При \texttt{-O3} время работы итеративной функции упало до $\approx 0.03$ мс, рекурсивной — до $1.4$ мс, что показывает, как агрессивные оптимизации могут уменьшить время работы, особенно для линейных алгоритмов.
    
    \item Для \texttt{-Os} время выполнения оказалось близким к \texttt{-O2}, но чуть быстрее для рекурсивного варианта, что свидетельствует о том, что оптимизации, направленные на уменьшение размера кода, в нашем случае не мешают скорости.
\end{itemize}

\paragraph*{Выводы}

Таким образом, проведённые эксперименты показывают, что:
\begin{itemize}
    \item оптимизации компилятора оказывают значительное влияние на производительность, особенно для рекурсивных алгоритмов;
    \item итеративный алгоритм оказался быстрее на всех уровнях оптимизации;
    \item для задач, чувствительных к скорости, рекомендуется использовать \texttt{-O2} или \texttt{-O3}, а для компактных программ, где важен размер, — \texttt{-Os}.
\end{itemize}

\subsubsection{Исследование разделяемых библиотек с помощью \texttt{ldd}}

На скриншоте \ref{fig:Screenshot_2025-06-30_at_16.40.24.png} видно вывод команды \texttt{ldd} для двух вариантов собранных программ:

\screenshot{Screenshot_2025-06-30_at_16.40.24.png}{Вывод команды \texttt{ldd} для программ \texttt{test\_dynamic} и \texttt{test\_static}}

\begin{itemize}
    \item \texttt{test\_dynamic} — программа, собранная с динамическим подключением библиотеки \texttt{libmax.so};
    \item \texttt{test\_static} — программа, в которую код библиотеки \texttt{max} был встроен статически.
\end{itemize}

Из результатов видно следующее:
\begin{itemize}
    \item Для \texttt{test\_dynamic} явно указана зависимость от локальной библиотеки \texttt{libmax.so}, расположенной в каталоге сборки. Это значит, что при запуске программа загрузит код функции поиска максимального элемента именно из этой разделяемой библиотеки.
    \item Для \texttt{test\_static} зависимости от \texttt{libmax.so} отсутствует, так как код был встроен в исполняемый файл на этапе компиляции. В выводе остаются лишь стандартные зависимости, такие как \texttt{libc.so.6}.
\end{itemize}

