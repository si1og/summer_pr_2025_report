\subsection{Тестирование и компиляция библиотеки поиска максимального элемента}

Для проверки корректности работы библиотеки поиска максимального элемента был создан каталог \texttt{tests}, в котором размещён файл \texttt{test.c}. 

\vspace{0.5cm}
\noindent
Ниже приводится краткое описание функций, использованных в тестовой программе:

\begin{itemize}
  \item \texttt{int myrand()} — простая реализация генератора псевдослучайных чисел. Использует фиксированный \texttt{seed}, что позволяет при каждом запуске получать одну и ту же последовательность случайных чисел. Это важно для корректного сравнения времени работы функций, так как они получают одинаковые данные на вход.

  \begin{itemize}
    \item \texttt{int myrand()}
    \begin{itemize}
      \item Использует глобальную переменную \texttt{seed}.
      \item Каждый раз перемножает \texttt{seed} на константу, добавляет другую константу, затем сдвигает и берёт маску.
      \item Возвращает «случайное» число от 0 до $2^{15}-1$.
      \item Благодаря фиксированному начальному \texttt{seed} при каждом запуске даёт одинаковую последовательность чисел.
    \end{itemize}
  \end{itemize}

\item \texttt{double measure(int (*func)(const int*, int), const int* arr, int size)} — функция измерения времени выполнения. Принимает указатель на функцию поиска максимума (\texttt{max\_iterative} или \texttt{max\_recursive}), массив и его размер. 
\begin{itemize}
    \item С помощью \texttt{gettimeofday} замеряется время до и после вызова функции поиска максимального элемента.
    \item Вычисляется затраченное время в миллисекундах, выводится результат (максимальный элемент) и это время на экран.
    \item Возвращает затраченное время в качестве значения типа \texttt{double}.
\end{itemize}

\item \texttt{int main()} — главная функция тестовой программы. 
  \begin{itemize}
      \item Создаёт массив из $100\,000$ случайных целых чисел с помощью функции \texttt{myrand}.
      \item Поочерёдно вызывает функцию \texttt{measure} для двух вариантов поиска максимального элемента: \texttt{max\_iterative} и \texttt{max\_recursive}.
      \item Таким образом, обеспечивает единообразное тестирование и вывод времени работы обоих алгоритмов на одном и том же массиве.
  \end{itemize}
\end{itemize}

\vspace{0.3cm}
\noindent\textbf{Замечание.} Тестирование было проведено только для типа \texttt{int}, так как написание отдельных тестовых программ для типов \texttt{char} и \texttt{double} не представлялось целесообразным — проверка общих свойств алгоритмов (итеративности и рекурсии) и их времени работы в достаточной степени демонстрируется на примере целых чисел.

\subsubsection{Сборка статической и динамической библиотек}

Для автоматизации процесса компиляции и линковки проекта был создан скрипт \texttt{CMakeLists.txt}, который редактировался в редакторе \texttt{nano}.
\vspace{0.5em}
В этом скрипте задаётся сборка библиотеки поиска максимального элемента в двух вариантах:
\begin{itemize}
\item \textbf{Статическая библиотека} (\texttt{libmax.a}), собираемая через:
\begin{lstlisting}
add_library(max_static STATIC ${MAX_SRC} ${MAX_HDR})
\end{lstlisting}
\item \textbf{Динамическая библиотека} (\texttt{libmax.so}), через:
\begin{lstlisting}
add_library(max_shared SHARED ${MAX_SRC} ${MAX_HDR})
\end{lstlisting}
\end{itemize}

Также описываются два исполняемых файла для тестирования этих библиотек:
\begin{itemize}
\item \texttt{test\_static} — программа, линкующаяся со статической версией библиотеки;
\item \texttt{test\_dynamic} — программа для динамической линковки.
\end{itemize}

Дополнительно используется установка свойств \texttt{BUILD\_RPATH} и \texttt{INSTALL\_RPATH} для \texttt{test\_dynamic}, чтобы исполняемый файл мог находить \texttt{libmax.so} в той же папке без дополнительных переменных окружения.

\vspace{.3cm}

\noindentНиже приведено описание работы CMakeLists.txt на псевдокоде:

\begin{itemize}
\item Устанавливается минимальная версия CMake: \texttt{3.10}.
\item Задаётся проект с именем \texttt{MaxLibTest} на языке С.
\item Устанавливается стандарт языка С на C99.

\item Определяются переменные:
\begin{itemize}
\item \texttt{MAX\_SRC} = \texttt{max.c} (исходный файл с реализацией функций)
\item \texttt{MAX\_HDR} = \texttt{max.h} (заголовочный файл с объявлениями)
\end{itemize}

\item Создаётся статическая библиотека:
\begin{itemize}
\item \texttt{add\_library(max\_static STATIC ...)}
\item Присваивается ей имя выходного файла \texttt{libmax.a} (через \texttt{OUTPUT\_NAME max})
\end{itemize}

\item Создаётся динамическая библиотека:
\begin{itemize}
\item \texttt{add\_library(max\_shared SHARED ...)}
\item Присваивается имя выходного файла \texttt{libmax.so} (также \texttt{OUTPUT\_NAME max})
\end{itemize}

\item Добавляется директория с заголовочными файлами в пути для компиляции.

\item Создаётся исполняемый файл \texttt{test\_static}, который компилируется из \texttt{tests/test.c} и связывается со статической библиотекой \texttt{max\_static}.

\item Создаётся исполняемый файл \texttt{test\_dynamic}, который компилируется из того же \texttt{tests/test.c}, но связывается с динамической библиотекой \texttt{max\_shared}.

\item Для \texttt{test\_dynamic} устанавливаются свойства \texttt{BUILD\_RPATH} и \texttt{INSTALL\_RPATH}, чтобы исполняемый файл во время выполнения автоматически находил \texttt{libmax.so} в каталоге сборки.
\end{itemize}

\vspace{0.5em}
\noindentПосле подготовки \texttt{CMakeLists.txt} проект собирался следующими командами:
\begin{lstlisting}
mkdir build
cd build
cmake ..
make
\end{lstlisting}
На скриншоте \ref{fig:Screenshot_2025-06-30_at_15.21.29.png} показан процесс сборки с помощью \texttt{CMake} и \texttt{Make}:

\screenshot{Screenshot_2025-06-30_at_15.21.29.png}{Процесс сборки проекта с созданием библиотек и исполняемых файлов.}

\vspace{0.5em}
В результате в каталоге \texttt{build} появились файлы:
\begin{itemize}
\item \texttt{libmax.a} — статическая библиотека;
\item \texttt{libmax.so} — динамическая библиотека;
\item \texttt{test\_static} — программа для теста со статической линковкой;
\item \texttt{test\_dynamic} — программа для теста с динамической линковкой.
\end{itemize}

\paragraph{Флаг компиляции}
Сборка происходила с использованием уровня оптимизации по умолчанию для CMake. На представленном скриншоте \texttt{CMakeLists.txt} отсутствует явный флаг \texttt{-O2}, значит компиляция прошла с флагом по умолчанию (обычно \texttt{-O0} или \texttt{-O2} в зависимости от предустановок CMake/компилятора).

Более подробно влияние флагов компиляции будет рассматриваться в следующем пункте.

\vspace{0.5em}
\paragraph{Тестирование}
На скриншоте \ref{fig:Screenshot_2025-06-30_at_15.23.01.png} показан запуск тестовых программ и вывод времени работы для статической и динамической версий:

\screenshot{Screenshot_2025-06-30_at_15.23.01.png}{Результаты запуска программ test\_dynamic и test\_static.}

Видно, что для обоих случаев итеративная версия поиска максимального элемента работает значительно быстрее рекурсивной. При этом результаты одинаковы, что подтверждает корректность реализации.

\subsubsection{Сборка с различными флагами оптимизации}

Для исследования влияния оптимизаций компилятора на производительность программы был составлен скрипт \texttt{test.bash}.

\vspace{.3cm}

\noindentНиже приведено его описание на псевдокоде:
\begin{itemize}
\item Для каждого оптимизационного флага компилятора \texttt{-O0}, \texttt{-O1}, \texttt{-O2}, \texttt{-O3}, \texttt{-Os} выполнить следующие шаги:
\begin{enumerate}
\item Вывести на экран сообщение: \texttt{"=== Building with -O... ==="}, где вместо \texttt{...} подставляется текущий флаг.
\item Запустить CMake с установкой переменной \texttt{CMAKE\_C\_FLAGS} равной текущему флагу оптимизации и собрать файлы в отдельный каталог сборки \texttt{build\_O...}, соответствующий флагу.
\item Затем выполнить команду сборки в этом каталоге (аналогично \texttt{make}).
\end{enumerate}
\end{itemize}

\noindent Этот скрипт автоматизирует процесс конфигурации и сборки проекта с различными значениями флага \texttt{-O}, проходя по ним в цикле. В результате для каждого уровня оптимизации создаётся отдельный каталог (\texttt{build\_O0}, \texttt{build\_O1} и т.д.), где собираются две версии программы: со статической и динамической линковкой.

На скриншотах \ref{fig:Screenshot_2025-06-30_at_15.48.38.png}, \ref{fig:Screenshot_2025-06-30_at_16.05.46.png}, \ref{fig:Screenshot_2025-06-30_at_16.06.23.png} и \ref{fig:Screenshot_2025-06-30_at_16.07.15.png} показан вывод выполнения скрипта и запуск тестов для каждого уровня оптимизации:

\screenshot{Screenshot_2025-06-30_at_15.48.38.png}{Запуск скрипта test.bash.}

\screenshot{Screenshot_2025-06-30_at_16.05.46.png}{Запуск тестов для статической и динамической линковки с \texttt{-O0} и \texttt{-O1}.}

\screenshot{Screenshot_2025-06-30_at_16.06.23.png}{Запуск тестов для  \texttt{-O2}, \texttt{-O3}.}

\screenshot{Screenshot_2025-06-30_at_16.07.15.png}{Запуск тестов для \texttt{-Os}.}

\subsubsection{Оптимизация компиляции и её влияние}

\begin{itemize}
    \item \texttt{-O0} — оптимизации отключены. Компилятор генерирует максимально «прямолинейный» и понятный код, близкий к исходному, что упрощает отладку, но замедляет исполнение.
    \item \texttt{-O1} — базовые оптимизации. Производятся простые преобразования кода для уменьшения размера и ускорения выполнения.
    \item \texttt{-O2} — более агрессивные оптимизации, включая развёртывание циклов, устранение мёртвого кода и др. Обычно используется по умолчанию для сборки релизов.
    \item \texttt{-O3} — включает все оптимизации \texttt{-O2} плюс дополнительные агрессивные, что может ускорить некоторые программы, но иногда приводит к большему размеру бинарного файла и непредсказуемым побочным эффектам.
    \item \texttt{-Os} — особый режим, при котором компилятор старается уменьшить размер исполняемого файла, при этом сохраняя большую часть оптимизаций \texttt{-O2}.
\end{itemize}

\paragraph*{Анализ экспериментов}

Из результатов, представленных на скриншотах выше, видно явное влияние уровня оптимизации на время работы функций:

\begin{itemize}
    \item Для \texttt{-O0} (без оптимизаций) рекурсивная функция работала значительно медленнее (около 12--13 мс), тогда как итеративная занимала около $0.3$ мс. Это объясняется отсутствием каких-либо преобразований кода и значительными накладными расходами на рекурсивные вызовы.
    
    \item Для \texttt{-O1} и \texttt{-O2} время выполнения рекурсивной версии заметно сократилось до $2$--$4$ мс, а итеративная снизилась до $\approx 0.05$--$0.1$ мс.
    
    \item При \texttt{-O3} время работы итеративной функции упало до $\approx 0.03$ мс, рекурсивной — до $1.4$ мс, что показывает, как агрессивные оптимизации могут уменьшить время работы, особенно для линейных алгоритмов.
    
    \item Для \texttt{-Os} время выполнения оказалось близким к \texttt{-O2}, но чуть быстрее для рекурсивного варианта, что свидетельствует о том, что оптимизации, направленные на уменьшение размера кода, в нашем случае не мешают скорости.
\end{itemize}
\begin{itemize}
  \item S. --- Static.
  \item D. --- Dynamic.
  \item I. --- Iterative.
  \item R. --- Recursive.
\end{itemize}

\begin{table}[H]
\centering
\caption{Абсолютное время работы функций, мс}
\begin{tabular}{|c|c|c|c|c|}
\hline
Оптимизация & S. I. (мс) & S. R. (мс) & D. I. (мс) & D. R. (мс)\\
\hline
-O0 & 0.322 & 12.975 & 0.325 & 4.277 \\
-O1 & 0.088 & 4.047 & 0.055 & 2.576 \\
-O2 & 0.172 & 1.834 & 0.129 & 2.269 \\
-O3 & 0.052 & 1.490 & 0.030 & 1.481 \\
-Os & 0.148 & 3.333 & 0.119 & 2.644 \\
\hline
\end{tabular}
\end{table}

\noindent $\Delta\%$ рассчитывается так:
\[
\Delta\% = \frac{T_{\mathrm{-O0}} - T_{\mathrm{opt}}}{T_{\mathrm{-O0}}} \times 100\%
\]

\noindentгде:
\begin{itemize}
  \item $T_{-O0}$ --- время без оптимизации;
  \item $T_{opt}$ --- время с выбранной оптимизацией.
\end{itemize}

\begin{table}[H]
\centering
\caption{Уменьшение времени относительно \texttt{-O0}, \%}
\begin{tabular}{|c|c|c|c|c|}
\hline
Оптимизация & S. I. ($\Delta\%$) & S. R. ($\Delta\%$) & D. I. ($\Delta\%$) & D. R. ($\Delta\%$)\\
\hline
-O0 & 0\% & 0\% & 0\% & 0\% \\
-O1 & 72.7\% & 68.8\% & 83.1\% & 39.8\% \\
-O2 & 46.6\% & 85.9\% & 60.3\% & 46.9\% \\
-O3 & 83.9\% & 88.5\% & 90.8\% & 65.4\% \\
-Os & 54.0\% & 74.3\% & 63.4\% & 38.2\% \\
\hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Прибавка к скорости выполнения по сравнению с \texttt{-O0}}
\begin{tabular}{|c|c|c|c|c|}
\hline
Оптимизация & S. I. & S. R. & D. I. & D. R. \\
\hline
-O0 & $1.00\times$ & $1.00\times$ & $1.00\times$ & $1.00\times$ \\
-O1 & $3.67\times$ & $3.21\times$ & $5.91\times$ & $1.66\times$ \\
-O2 & $1.87\times$ & $7.09\times$ & $2.52\times$ & $1.88\times$ \\
-O3 & $6.21\times$ & $8.69\times$ & $10.85\times$ & $2.89\times$ \\
-Os & $2.17\times$ & $3.90\times$ & $2.73\times$ & $1.62\times$ \\
\hline
\end{tabular}
\end{table}


\paragraph*{Выводы по результатам экспериментов}

Из полученных данных видно, что уровни оптимизации компилятора существенно влияют на скорость выполнения программы.  
Для итеративной реализации функции нахождения максимального элемента ускорение по сравнению с отсутствием оптимизаций (\texttt{-O0}) достигает до $90\%$ при использовании флага \texttt{-O3}.  
Рекурсивная реализация ускоряется менее значительно --- примерно на $65\%$ для динамически слинкованного варианта при \texttt{-O3}, что связано с тем, что компилятор может меньше оптимизировать глубокие рекурсивные вызовы.

Кроме того, видно, что использование статической или динамической линковки не оказывает критичного влияния на результаты, но в некоторых случаях динамический вариант оказывается чуть быстрее, что можно объяснить особенностями загрузки и размещения кода в памяти.

Оптимизация под размер кода (\texttt{-Os}) также показала хорошие результаты и близка к \texttt{-O2} по скорости работы, особенно для рекурсивного варианта.

Таким образом, для поиска максимального в массиве наиболее эффективным оказался уровень оптимизации \texttt{-O3}.

\subsubsection{Исследование разделяемых библиотек с помощью \texttt{ldd}}

На скриншоте \ref{fig:Screenshot_2025-06-30_at_16.40.24.png} видно вывод команды \texttt{ldd} для двух вариантов собранных программ:

\screenshot{Screenshot_2025-06-30_at_16.40.24.png}{Вывод команды \texttt{ldd} для программ \texttt{test\_dynamic} и \texttt{test\_static}.}

\begin{itemize}
    \item \texttt{test\_dynamic} — программа, собранная с динамическим подключением библиотеки \texttt{libmax.so};
    \item \texttt{test\_static} — программа, в которую код библиотеки \texttt{max} был встроен статически.
\end{itemize}

Из результатов видно следующее:
\begin{itemize}
    \item Для \texttt{test\_dynamic} явно указана зависимость от локальной библиотеки \texttt{libmax.so}, расположенной в каталоге сборки. Это значит, что при запуске программа загрузит код функции поиска максимального элемента именно из этой разделяемой библиотеки.
    \item Для \texttt{test\_static} зависимости от \texttt{libmax.so} отсутствует, так как код был встроен в исполняемый файл на этапе компиляции. В выводе остаются лишь стандартные зависимости, такие как \texttt{libc.so.6}.
\end{itemize}

\subsubsection{Использование подгружаемых библиотек через \texttt{dlopen}}

Для выполнения пункта задания, связанного с использованием механизма подгружаемых библиотек, была модифицирована тестовая программа.
В существующем файле \texttt{tests/test.c} изменений не производилось, а вместо этого был создан новый файл \texttt{tests/test\_dlopen.c}, в котором функции \texttt{max\_iterative} и \texttt{max\_recursive} загружаются динамически во время исполнения программы с помощью \texttt{dlopen} и \texttt{dlsym}.

Основные отличия по сравнению с исходным вариантом заключаются в следующем:
\begin{itemize}
\item Подключена библиотека \texttt{<dlfcn.h>} для использования функций \texttt{dlopen}, \texttt{dlsym} и \texttt{dlclose}.
\item Добавлен вызов \texttt{dlopen("./libmax.so", RTLD\_LAZY)} для загрузки динамической библиотеки во время выполнения.
\item Получение адресов функций осуществляется через \texttt{dlsym}, после чего тестирование выполняется так же, как и в исходном варианте.
\end{itemize}

\vspace{.3cm}
\noindentНиже более подробное описание работы тестирующей программы:

\begin{itemize}
  \item Получить адреса функций из библиотеки:
  \begin{lstlisting}
  max_iterative := dlsym(handle, "max_iterative")
  если ошибка через dlerror():
      вывести сообщение и завершить программу
  
  max_recursive := dlsym(handle, "max_recursive")
  если ошибка через dlerror():
      вывести сообщение и завершить программу
  \end{lstlisting}
  
  \item Сгенерировать массив случайных чисел с помощью \texttt{myrand}.
  
  \item Замерить время работы полученных функций так же, как раньше:
  \begin{lstlisting}
  вызвать measure(max_iterative, arr, SIZE)
  вызвать measure(max_recursive, arr, SIZE)
  \end{lstlisting}
  
  \item Закрыть библиотеку:
  \begin{lstlisting}
  dlclose(handle)
  \end{lstlisting}
\end{itemize}

\vspace{.3cm}

\noindentПрограмма собирается командой:
\begin{verbatim}
gcc tests/test_dlopen.c -ldl -o test_dlopen
\end{verbatim}

Результаты тестирования при запуске программы приведены на скриншоте ниже --- \ref{fig:Screenshot_2025-07-01_at_11.38.34.png}.

\screenshot{Screenshot_2025-07-01_at_11.38.34.png}
{Запуск тестовой программы с использованием \texttt{dlopen} и измерение времени выполнения итеративной и рекурсивной функции поиска максимального элемента.}

Таким образом, главным отличием является то, что при \texttt{dlopen} загрузка и связывание выполняется явно на уровне пользовательского кода во время работы программы, что даёт возможность динамически выбирать загружаемую библиотеку или обработать ошибку отсутствия библиотеки без аварийного завершения программы.