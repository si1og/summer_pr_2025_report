\subsection{Задание 2. Двоичные файлы и визуализация структур в псевдографике}

\subsubsection{Описание структуры из индивидуального варианта}

В рамках данного задания была составлена структура для хранения информации о человеке, включающая следующие поля:
\begin{itemize}
  \item \textbf{Фамилия и инициалы} --- строка фиксированной длины (до 64 символов),
  \item \textbf{Знак зодиака} --- строка фиксированной длины (до 32 символов),
  \item \textbf{Год рождения} --- целое число, представляющее год.
\end{itemize}

Редактирование исходного кода структуры производилось в текстовом редакторе \texttt{nano} на гостевой системе через SSH-сессию. На скриншоте представлен процесс создания файла \texttt{znak.h} и внесение в него описания структуры:

\screenshot{Screenshot_2025-06-27_at_03.25.08.png}{Редактирование структуры ZNAK в файле \texttt{znak.h} с помощью nano}

\noindentСтруктура была реализована следующим образом:
\begin{lstlisting}[language=C, numbers=left, caption=Описание структуры ZNAK, ,numbers=left]
#define NAME_LEN 64
#define ZODIAC_LEN 32

typedef struct {
    char name[NAME_LEN];
    char zodiac[ZODIAC_LEN];
    int birth_year;
} ZNAK;
\end{lstlisting}

\subsubsection{Описание заголовка базы данных}

Также была составлена структура заголовка бинарного файла базы данных. Она содержит следующие поля:
\begin{itemize}
  \item \textbf{Сигнатура формата файла} --- первые 4 байта файла, в которые записывается ``SEME'' (по первым буквам фамилии Semenov). Это позволяет в дальнейшем при чтении файла проверить, соответствует ли файл ожидаемому формату.
  
  \item \textbf{Номер транзакции} (\texttt{transaction\_id}) --- целое число (4 байта), которое увеличивается при каждом обращении к файлу, как при чтении, так и при записи. Это даёт возможность отследить количество операций с файлом и потенциальные изменения данных.
  
  \item \textbf{Количество записей} (\texttt{count}) --- целое число (4 байта), указывающее сколько структур ZNAK находится в данном файле после заголовка.
  
  \item \textbf{Контрольная сумма (CRC-32)} --- вычисляется по алгоритму CRC-32 для всех данных, следующих за заголовком. Она нужна для того, чтобы в любой момент можно было проверить целостность данных: если файл будет повреждён или модифицирован некорректно, пересчитанная контрольная сумма не совпадёт с записанной, и можно будет определить, что данные ненадёжны.
\end{itemize}

Редактирование исходного файла, содержащего как структуру данных о человеке, так и структуру заголовка базы данных, производилось в редакторе \texttt{nano}, что показано на скриншоте ниже:

\screenshot{Screenshot_2025-06-27_at_03.32.39.png}{Редактирование структуры заголовка ZNAK\_DB\_HEADER и структуры ZNAK в nano}

\noindentПример кода заголовка базы данных в \texttt{znak.h}:
\begin{lstlisting}[language=C, numbers=left, caption=Структура заголовка бинарного файла, ,numbers=left]
typedef struct {
    char signature[4];
    uint32_t transaction_id;
    uint32_t count;
    uint32_t checksum;
} ZNAK_DB_HEADER;
\end{lstlisting}

Таким образом, заголовок обеспечивает:
\begin{itemize}
  \item идентификацию формата файла с помощью сигнатуры;
  \item учёт количества операций чтения/записи через transaction\_id;
  \item хранение информации о количестве записей в базе;
  \item проверку целостности данных с помощью CRC-32.
\end{itemize}

\subsubsection*{Использование \texttt{uint32\_t} вместо \texttt{int}}

Для описания полей заголовка базы данных (\texttt{transaction\_id}, \texttt{count}, \texttt{checksum}) был использован тип \texttt{uint32\_t} из заголовочного файла \texttt{<stdint.h>}, а не привычный \texttt{int}. Это сделано по следующим причинам:

\begin{itemize}
  \item \textbf{Гарантированный размер:} 
  Тип \texttt{uint32\_t} представляет собой \textbf{беззнаковое целое ровно 4 байта (32 бита)} на всех платформах. В то время как \texttt{int} в языке C лишь гарантирует, что будет не менее 2 байт (обычно 4 байта, но это зависит от архитектуры и компилятора).

  \item \textbf{Переносимость бинарного формата:}
  Так как база данных сохраняется в бинарном формате, важно, чтобы структура файла выглядела одинаково на всех системах (например, x86, ARM). Использование \texttt{uint32\_t} позволяет гарантировать, что поля заголовка будут точно занимать 4 байта, а значит файл можно будет прочитать на любой платформе.

  \item \textbf{Отсутствие знака для идентификаторов и счётчиков:}
  Поля \texttt{transaction\_id}, \texttt{count} и \texttt{checksum} не могут быть отрицательными по своей природе. Использование беззнакового типа \texttt{uint32\_t} явно показывает, что эти значения не должны быть отрицательными, и исключает возможность их интерпретации как отрицательных чисел.
\end{itemize}

\subsubsection{Реализация программы с использованием ncurses для работы с бинарной базой данных}

В рамках данного задания была составлена программа на языке \texttt{C}, использующая библиотеку \texttt{ncurses} для визуализации работы с двоичным файлом базы данных. Программа включает:

\begin{itemize}
    \item интерфейс для ввода и отображения записей;
    \item хранение данных в бинарном файле со специальным заголовком;
    \item выполнение индивидуального задания --- поиск по знаку зодиака и году рождения;
    \item возможность добавления записей с обновлением заголовка.
\end{itemize}

\subsubsection*{Использование библиотеки \texttt{ncurses} и \texttt{zlib}}

При реализации программы использовались две важные внешние библиотеки:

\begin{itemize}
    \item \textbf{\texttt{ncurses}} — для организации псевдографического интерфейса в терминале;
    \item \textbf{\texttt{zlib}} — для вычисления контрольной суммы данных в формате CRC-32.
\end{itemize}

\subsubsection{Работа с библиотекой \texttt{ncurses}}

Библиотека \texttt{ncurses} предоставляет набор функций для работы с текстовым интерфейсом в терминале, включая управление выводом текста, перемещением курсора, очисткой экрана и считыванием пользовательского ввода без перехода на новую строку.

В программе использовались следующие функции:
\begin{itemize}
    \item \texttt{initscr()}, \texttt{endwin()} — инициализация и завершение работы с экраном;
    \item \texttt{cbreak()}, \texttt{noecho()}, \texttt{echo()} — настройка режима ввода (без ожидания Enter, а также включение/отключение отображения вводимых символов на экране; например, \texttt{noecho()} используется для того, чтобы не выводить вводимые пользователем символы непосредственно в терминале, а выводить их вручную через \texttt{mvprintw()});
    \item \texttt{setlocale(LC\_ALL, "ru\_RU.UTF-8")} — установка локали для корректного вывода и обработки кириллицы в интерфейсе (поддержка UTF-8 для псевдографики и русских символов);
    \item \texttt{clear()}, \texttt{move()}, \texttt{clrtoeol()} — очистка всего экрана или отдельных строк;
    \item \texttt{mvprintw()} — вывод форматированного текста в заданную позицию;
    \item \texttt{getnstr()}, \texttt{scanw()}, \texttt{getch()} — считывание строк, чисел и одиночных символов от пользователя;
    \item \texttt{getmaxyx()} — получение размеров терминала для реализации постраничного вывода.
\end{itemize}

Благодаря \texttt{ncurses} был реализован удобный интерфейс с полями ввода, сообщениями об ошибках и навигацией между страницами при отображении большого количества записей в базе данных.

\subsubsection{Использование библиотеки \texttt{zlib}}

Библиотека \texttt{zlib} использовалась для расчёта контрольной суммы всех данных, хранящихся в файле базы. Это позволяет в дальнейшем проверить целостность базы данных, так как любое повреждение файла изменит значение CRC-32.

Программа применяет следующие функции из \texttt{zlib.h}:
\begin{itemize}
    \item \texttt{crc32(0L, Z\_NULL, 0)} — инициализация значения контрольной суммы;
    \item \texttt{crc32(previous\_crc, (const Bytef*)data, size)} — вычисление CRC-32 для заданного блока данных.
\end{itemize}

Контрольная сумма записывается в заголовок базы данных и обновляется при каждом изменении данных, например, при добавлении новой записи.

\subsubsection{Исходные файлы программы}

Программа разбита на несколько модулей:

\begin{itemize}
    \item \texttt{znak.h} --- описание структур данных;
    \item \texttt{app.h} --- объявления функций работы с интерфейсом и файлами;
    \item \texttt{app.c} --- реализация функций интерфейса, работы с файлом и структуры базы;
    \item \texttt{main.c} --- точка входа и главное меню.
\end{itemize}

\subsubsection*{Файл \texttt{znak.h}}

\noindent
Файл \texttt{znak.h}, который был подробно рассмотрен ранее, приведён ниже для удобства. 

\begin{lstlisting}[language=C, numbers=left, caption=znak.h]
#define NAME_LEN 64
#define ZODIAC_LEN 32

#include <stdint.h>
#include <zlib.h>

typedef struct {
    char name[NAME_LEN];
    char zodiac[ZODIAC_LEN];
    int birth_year;
} ZNAK;

typedef struct {
    char signature[4];
    uint32_t transaction_id;
    uint32_t count;
    uint32_t checksum;
} ZNAK_DB_HEADER;
\end{lstlisting}

\subsubsection*{Файл \texttt{app.h}}

Заголовочный файл с объявлениями всех функций и необходимых констант:

\begin{lstlisting}[language=C, numbers=left, caption=app.h]
#include "znak.h"

#define DB_FILENAME "znak_db"
#define MAX_RECORDS 100

void input_znak(ZNAK *z);
void save_db(ZNAK_DB_HEADER *header, ZNAK *arr, int count);
void find_by_year_and_zodiac(ZNAK_DB_HEADER *header, ZNAK *arr, int count, const char *zodiac, int year);
void add_record(ZNAK_DB_HEADER *header, ZNAK *arr, int *count);
void search_records(ZNAK_DB_HEADER *header, ZNAK *arr, int count);
void print_db_header(ZNAK_DB_HEADER *header);
void db_print_interface(ZNAK_DB_HEADER *header, ZNAK *arr, int count);
void print_db(ZNAK_DB_HEADER *header, ZNAK arr, int count);
void error_msg(const char *msg);
void clear_except_first_line();
\end{lstlisting}

\noindent
В этом заголовочном файле задекларированы все функции программы, необходимые для работы с ncurses и двоичным файлом базы данных. Приведём краткое описание каждой функции:
\begin{itemize}
  \item \texttt{save\_db(ZNAK\_DB\_HEADER *header, ZNAK *arr, int count)} — сохраняет в бинарный файл заголовок и массив структур \texttt{ZNAK}, обновляя контрольную сумму и увеличивая номер транзакции при каждом сохранении.
  
  \item \texttt{find\_by\_year\_and\_zodiac(...)} — осуществляет поиск по базе данных по заданным году рождения и знаку зодиака. Отображает найденные результаты в виде таблицы на экране.
  
  \item \texttt{add\_record(...)} — добавляет новую запись в массив, корректирует заголовок (увеличивает количество записей и номер транзакции), после чего сразу сохраняет базу на диск.
  
  \item \texttt{search\_records(...)} — интерфейс поиска: запрашивает у пользователя необходимые параметры (год и знак зодака), после чего вызывает функцию \texttt{find\_by\_year\_and\_zodiac} для выполнения поиска.
  
  \item \texttt{print\_db\_header(...)} — выводит информацию о заголовке базы данных: сигнатуру, номер транзакции, число записей и CRC-32 контрольную сумму.
  
  \item \texttt{db\_print\_interface(...)} — основной интерфейс для просмотра всех записей в базе с постраничным выводом и управлением навигацией через клавиши \texttt{n}, \texttt{p}, \texttt{q}.
  
  \item \texttt{print\_db(...)} — вспомогательная функция, используемая для табличного вывода всех записей без информации о заголовке.
  
  \item \texttt{error\_msg(const char *msg)} — показывает сообщение об ошибке в ncurses-окне и ждёт нажатия клавиши для продолжения работы.
  
  \item \texttt{clear\_except\_first\_line()} — очищает весь экран кроме первой строки, что позволяет аккуратно обновлять интерфейс, сохраняя статусную строку.
\end{itemize}

\subsubsection*{Файл \texttt{app.c}}

Ниже представлена реализация всех функций, обеспечивающих работу программы с использованием библиотеки \texttt{ncurses} и двоичного файла базы данных. Здесь сосредоточена вся прикладная логика, включая интерфейс ввода/вывода, работу с заголовком, чтение и запись файла, обработку ошибок и механизм постраничного отображения.

\subsubsection*{Вывод сообщений об ошибках}

Функция \texttt{error\_msg} предназначена для отображения сообщений об ошибках в интерфейсе \texttt{ncurses}. Она очищает экран, выводит переданное ей текстовое сообщение на первой строке и подсказку для пользователя на третьей строке о необходимости нажать любую клавишу для продолжения. После нажатия клавиши экран снова очищается, позволяя вернуться к нормальному взаимодействию программы.

\begin{lstlisting}[language=C, caption=Функция error\_msg, numbers=left]
void error_msg(const char* msg) {
  clear();
  mvprintw(1, 2, msg);
  mvprintw(3, 2, "Нажмите любую клавишу для повторной попытки...");
  getch();
  clear();
}
\end{lstlisting}

\subsubsection*{Функция ввода записи}

Функция \texttt{input\_znak} обеспечивает пошаговый ввод пользователем данных для полей структуры \texttt{ZNAK}: фамилии и инициалов, знака зодиака и года рождения, с использованием интерфейса \texttt{ncurses}. Для строковых полей предусмотрены проверки на пустой ввод, а для года рождения — проверка диапазона от 1899 до 2025. Все данные сразу записываются в соответствующие поля структуры.

\begin{lstlisting}[language=C, caption=Функция input\_znak, ,numbers=left]
void input_znak(ZNAK *z) {
  echo();
  while (1) {
    mvprintw(2, 2, "Фамилия и инициалы: ");
    getnstr(z->name, sizeof(z->name) - 1);
    if (strlen(z->name) > 0) break;
    error_msg("Фамилия и инициалы не могут быть пустыми.");
  }

  while (1) {
    mvprintw(3, 2, "Знак зодиака: ");
    getnstr(z->zodiac, sizeof(z->zodiac) - 1);
    if (strlen(z->zodiac) > 0) break;
    error_msg("Знак зодиака не может быть пустым.");
  }

  while (1) {
    int birth_year = 0;
    mvprintw(4, 2, "Год рождения: ");
    scanw("%d", &birth_year);
    if (birth_year >= 1899 && birth_year <= 2025) {
      z->birth_year = birth_year;
      break;
    } else {
      error_msg("Год рождения должен быть в диапазоне 1899-2025.");
    }
  }
  noecho();
}
\end{lstlisting}

\subsubsection*{Сохранение базы в файл}

Функция \texttt{save\_db} предназначена для сохранения текущего состояния базы данных в бинарный файл. Сначала открывается файл для записи в бинарном режиме, при этом при ошибке открытия выводится сообщение с помощью \texttt{perror}. Затем обновляется поле \texttt{count} заголовка, инкрементируется \texttt{transaction\_id}, и вычисляется контрольная сумма CRC32 по всем данным массива структур для последующей проверки целостности. После этого в файл последовательно записываются заголовок и массив структур. В завершение файл закрывается.

\begin{lstlisting}[language=C, caption=Функция save\_db, numbers=left]
void save_db(ZNAK_DB_HEADER *header, ZNAK *arr, int count) {
  FILE* file = fopen(DB_FILENAME, "wb");
  if (!file) {
    perror("Ошибка создания файла");
    return;
  }

  header->count = count;
  header->transaction_id++;
  header->checksum = crc32(0L, Z_NULL, 0);
  header->checksum = crc32(header->checksum, 
  (const Bytef*)arr, sizeof(ZNAK) * count);

  fwrite(header, sizeof(ZNAK_DB_HEADER), 1, file);
  fwrite(arr, sizeof(ZNAK), count, file);
  fclose(file);
}
\end{lstlisting}

\subsubsection*{Добавление новой записи в базу данных}

Функция \texttt{add\_record} реализует режим добавления одной новой записи в массив структур. При вызове она очищает экран, выводит заголовок с сообщением о начале добавления записи, затем с помощью функции \texttt{input\_znak} запрашивает у пользователя данные для новой структуры. После успешного ввода увеличивает счётчик элементов массива и сразу сохраняет обновлённую базу данных в файл с помощью функции \texttt{save\_db}.

\begin{lstlisting}[language=C, caption=Функция add\_record], numbers=left]
void add_record(ZNAK_DB_HEADER *header, ZNAK *arr, int *count) {
  clear();
  mvprintw(1, 2, "Добавление новой записи:");
  input_znak(&arr[*count]);
  (*count)++;
  save_db(header, arr, *count);
}
\end{lstlisting}

\subsubsection*{Вывод заголовка базы данных}
Данная функция отвечает за отображение основной служебной информации о бинарной базе данных на экран. Она выводит сигнатуру, номер транзакции, количество записей в базе и контрольную сумму CRC32, обеспечивающую целостность данных. После вывода всех полей заголовка пользователю предлагается нажать любую клавишу для продолжения.

\begin{lstlisting}[language=C, caption=Функция print\_db\_header, numbers=left]
void print_db_header(ZNAK_DB_HEADER *header) {
  clear();
  mvprintw(1, 2, "Заголовок базы данных:");
  mvprintw(2, 4, "Сигнатура: %.4s", header->signature);
  mvprintw(3, 4, "Номер транзакции: %u", header->transaction_id);
  mvprintw(4, 4, "Количество записей: %u", header->count);
  mvprintw(5, 4, "Контрольная сумма (CRC32): %u", header->checksum);

  mvprintw(20, 2, "Нажмите любую клавишу для выхода...");
  getch();
}
\end{lstlisting}

\subsubsection*{Очистка экрана за исключением первой строки}
Функция \texttt{clear\_except\_first\_line} используется для очистки терминала с помощью библиотеки \texttt{ncurses}, оставляя нетронутой первую строку экрана. Это достигается за счёт прохода в цикле по строкам начиная со второй и вызова \texttt{clrtoeol} для стирания содержимого каждой строки. Таким образом обеспечивается возможность сохранения заголовка или другого важного сообщения в верхней части экрана при обновлении основного содержимого.

\begin{lstlisting}[language=C, caption=Функция clear\_except\_first\_line, numbers=left]
void clear_except_first_line() {
  int rows, cols;
  getmaxyx(stdscr, rows, cols);

  for (int i = 2; i <= rows; ++i) {
    move(i, 0);
    clrtoeol();
  }
}
\end{lstlisting}

\subsubsection*{Интерфейс просмотра базы данных с постраничным выводом}
Функция \texttt{db\_print\_interface} организует интерфейс просмотра содержимого базы данных в виде таблицы с постраничной навигацией. С помощью возможностей библиотеки \texttt{ncurses} она отрисовывает заголовки столбцов («№», «Фамилия и инициалы», «Знак зодиака», «Год») и строки таблицы, где каждая строка соответствует одной записи структуры \texttt{ZNAK}. Вывод делится на страницы, количество записей на странице зависит от размеров текущего окна терминала. Пользователь может листать данные с помощью клавиш \texttt{n} (следующая страница) и \texttt{p} (предыдущая страница), либо выйти, нажав \texttt{q}.

\begin{lstlisting}[language=C, caption=Функция db\_print\_interface, numbers=left]
void db_print_interface(ZNAK_DB_HEADER *header, ZNAK *arr, int count) {
  int rows, cols;
  getmaxyx(stdscr, rows, cols);
  
  int lines_per_page = rows - 10;
  int start = 0;
  
  while (start < count) {
    clear_except_first_line();
    mvprintw(2, 4, "%-7s %-41s %-26s %-5s", "№", 
    "Фамилия и инициалы", "Знак зодиака", "Год");
    mvhline(3, 4, '-', cols - 8);

    int i, row = 4;
    for (i = start; i < count && i < start + lines_per_page; ++i) {
      mvprintw(row++, 4, "%-5d %-25s %-15s %-5d",
                i + 1, arr[i].name, arr[i].zodiac, arr[i].birth_year);
    }

    mvprintw(rows - 2, 2,
"Страница %d/%d. Нажмите 'n' для следующей, 
'p' для предыдущей, 'q' для выхода.",
      (start / lines_per_page) + 1,
      (count + lines_per_page - 1) / lines_per_page);

    int ch = getch();
    if (ch == 'q' || ch == 'Q')
      break;
    else if (ch == 'n' || ch == 'N')
      start += lines_per_page;
    else if (ch == 'p' || ch == 'P') {
      if (start - lines_per_page >= 0)
        start -= lines_per_page;
    } else
      break;
  }
}
\end{lstlisting}

\subsubsection*{Вывод содержимого базы данных}

Функция \texttt{print\_db} используется для вывода всех записей базы данных на экран. Сначала она очищает экран и вызывает \texttt{save\_db} для актуализации заголовка и пересчёта контрольной суммы. Затем выводит заголовок с сообщением \texttt{"Содержимое базы данных:"} и передаёт управление функции \texttt{db\_print\_interface}, которая обеспечивает постраничную навигацию и форматированный вывод записей.

\begin{lstlisting}[language=C, caption=Функция print\_db, numbers=left]
void print_db(ZNAK_DB_HEADER *header, ZNAK *arr, int count) {
  clear();
  save_db(header, arr, count);
  mvprintw(1, 2, "Содержимое базы данных:");
  db_print_interface(header, arr, count);
}
\end{lstlisting}

\subsubsection*{Поиск по знаку зодиака и году}

Функция \texttt{find\_by\_year\_and\_zodiac} выполняет поиск записей в базе данных по указанному знаку зодиака и году рождения. Сначала она вызывает \texttt{save\_db}, чтобы обновить заголовок и пересчитать контрольную сумму базы. Затем формирует временный массив найденных записей, проходя по всем данным и сравнивая значения. Если совпадения есть, вызывает \texttt{db\_print\_interface} для постраничного вывода результатов. Если совпадений не найдено, выводит соответствующее сообщение и ждёт нажатия клавиши для возврата в меню.

\begin{lstlisting}[language=C, caption=Функция find\_by\_year\_and\_zodiac, numbers=left]
void find_by_year_and_zodiac(ZNAK_DB_HEADER *header, 
  ZNAK *arr, int count, const char *zodiac, int year) {
  save_db(header, arr, count);

  int found = 0;

  ZNAK found_arr[count];
  for (int i = 0; i < count; ++i) {
    if (arr[i].birth_year == year && \
      strcmp(arr[i].zodiac, zodiac) == 0) {
      found_arr[found++] = arr[i];
    }
  }
  
  clear();
  mvprintw(1, 2, "Результаты поиска по знаку \"%s\" и году %d:",
          zodiac, year);

  if (found) {
    db_print_interface(header, found_arr, found);
  } else {
    mvprintw(5, 4, "Совпадений не найдено.");
    mvprintw(20, 2, "Нажмите любую клавишу для выхода...");
    getch();
  }
}
\end{lstlisting}
\subsubsection*{Запрос параметров для поиска}

Функция \texttt{search\_records} отвечает за интерфейс ввода пользователем параметров поиска. Она очищает экран, запрашивает у пользователя знак зодиака и год рождения с помощью \texttt{getnstr} и \texttt{scanw}. После этого передаёт введённые данные в функцию \texttt{find\_by\_year\_and\_zodiac}, которая непосредственно выполняет поиск и выводит результаты.

\begin{lstlisting}[language=C, caption=Функция search\_records, numbers=left]
void search_records(ZNAK_DB_HEADER *header, ZNAK *arr, int count) {
  char search_zodiac[ZODIAC_LEN];
  int search_year;

  clear();
  mvprintw(1, 2, "Введите знак зодиака: ");
  echo();
  getnstr(search_zodiac, sizeof(search_zodiac) - 1);
  noecho();

  mvprintw(2, 2, "Введите год рождения: ");
  echo();
  scanw("%d", &search_year);
  noecho();

  find_by_year_and_zodiac(header, arr, count, search_zodiac, search_year);
}
\end{lstlisting}

\subsubsection*{Файл \texttt{main.c}}

Ниже представлена реализация главной управляющей функции программы, в которой происходит инициализация работы с терминалом с помощью библиотеки \texttt{ncurses}, установка локали для поддержки UTF-8, а также организация всего цикла взаимодействия с пользователем.

\begin{lstlisting}[language=C, numbers=left, caption=main.c]
#include <ncurses.h>
#include <locale.h>
#include "app.h"

int main() {
  setlocale(LC_ALL, "ru_RU.UTF-8");
  initscr();
  cbreak();
  noecho();

  ZNAK records[MAX_RECORDS];
  int count = 0;

  ZNAK_DB_HEADER header;

  FILE *file = fopen(DB_FILENAME, "rb");
  if (!file) {
    memcpy(header.signature, "SEME", 4);
    header.transaction_id = 0;
    header.count = 0;
    header.checksum = 0;

    while (1) {
      clear();
      mvprintw(1, 2, "Файл не найден. Введите количество записей: ");
      echo();
      scanw("%d", &count);
      noecho();

      if (count <= MAX_RECORDS && count >= 1) {
        for (int i = 0; i < count; ++i) {
          clear();
          mvprintw(1, 2, "Запись %d", i + 1);
          input_znak(&records[i]);
        }

        save_db(&header, records, count);
        break;
      } else {
        error_msg("Количество должно быть числом от 1 до 100.");
      }
    }
  } else {
    fread(&header, sizeof(ZNAK_DB_HEADER), 1, file);
    count = header.count;
    fread(records, sizeof(ZNAK), count, file);
    fclose(file);
  }

  int choice;
  while (1) {
    clear();
    mvprintw(2, 2, "1. Просмотр заголовка базы данных");
    mvprintw(3, 2, "2. Просмотр всех записей базы данных");
    mvprintw(4, 2, "3. Поиск по знаку зодиака и году");
    mvprintw(5, 2, "4. Добавить запись");
    mvprintw(6, 2, "5. Выход");
    mvprintw(8, 2, "Ваш выбор: ");
    echo();
    scanw("%d", &choice);
    noecho();

    if (choice == 1) {
      print_db_header(&header);
    } else if (choice == 2) {
      clear();
      FILE *file = fopen(DB_FILENAME, "rb");
      if (file) {
        ZNAK_DB_HEADER header;
        fread(&header, sizeof(ZNAK_DB_HEADER), 1, file);
        fread(records, sizeof(ZNAK), header.count, file);
        count = header.count;
        fclose(file);

        print_db(&header, records, count);
      } else {
        mvprintw(2, 2, "Файл базы данных не найден.");
      }
    } else if (choice == 3) {
      search_records(&header, records, count);
    } else if (choice == 4) {
      add_record(&header, records, &count);
    } else if (choice == 5) {
      break;
    }
  }
  endwin();
  return 0;
}
\end{lstlisting}

\vspace{0.2cm}

В этой функции осуществляется следующий общий сценарий работы программы:
\begin{itemize}
    \item Настраивается локаль с помощью \texttt{setlocale} для поддержки кириллицы и псевдографики, а также инициализируется библиотека \texttt{ncurses}.
    \item Выполняется попытка открыть файл базы данных. Если файл не найден, пользователю предлагается создать новую базу, ввести количество записей и последовательно заполнить их через функцию \texttt{input\_znak}, после чего база сохраняется.
    \item Если файл найден, загружаются заголовок и данные базы.
    \item Далее запускается главный цикл работы с пользователем, где по пунктам меню можно:
    \begin{itemize}
        \item просмотреть заголовок базы данных,
        \item просмотреть все записи,
        \item выполнить поиск по знаку зодиака и году,
        \item добавить новую запись в базу,
        \item завершить программу.
    \end{itemize}
    \item При завершении работы вызывается \texttt{endwin()}, корректно завершая режим ncurses.
\end{itemize}


\subsubsection*{Замечание о сборке, тестировании и исследовании зависимостей}

Сборочные файлы, тестирующие программы, а также все эксперименты по запуску и исследованию работы разработанной программы находятся в отдельном разделе \textbf{«Результаты работы и эксперименты»}.

\vspace{0.3cm}

В данном разделе будут приведены:
\begin{itemize}
    \item подробное описание сборки программы с использованием \texttt{CMakeLists.txt};
    \item результаты тестирования работы приложения с различными наборами данных;
    \item исследование разделяемых библиотек в полученной программе с помощью утилиты \texttt{ldd};
    \item построение рекурсивного дерева зависимостей на основе результатов работы \texttt{ldd}.
\end{itemize}