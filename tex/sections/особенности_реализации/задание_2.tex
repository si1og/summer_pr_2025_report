\subsection{Задание 2. Двоичные файлы и визуализация структур в псевдографике}

\subsubsection{Описание структуры из индивидуального варианта}

В рамках данного задания была составлена структура для хранения информации о человеке, включающая следующие поля:
\begin{itemize}
  \item \textbf{Фамилия и инициалы} --- строка фиксированной длины (до 64 символов),
  \item \textbf{Знак зодиака} --- строка фиксированной длины (до 32 символов),
  \item \textbf{Год рождения} --- целое число, представляющее год.
\end{itemize}

Редактирование исходного кода структуры производилось в текстовом редакторе \texttt{nano} на гостевой системе через SSH-сессию. На скриншоте представлен процесс создания файла \texttt{znak.h} и внесение в него описания структуры:

\screenshot{Screenshot_2025-06-27_at_03.25.08.png}{Редактирование структуры ZNAK в файле \texttt{znak.h} с помощью nano}

\subsubsection{Описание заголовка базы данных}

Также была составлена структура заголовка бинарного файла базы данных. Она содержит следующие поля:
\begin{itemize}
  \item \textbf{Сигнатура формата файла} --- первые 4 байта файла, в которые записывается ``SEME'' (по первым буквам фамилии Semenov). Это позволяет в дальнейшем при чтении файла проверить, соответствует ли файл ожидаемому формату.
  
  \item \textbf{Номер транзакции} (\texttt{transaction\_id}) --- целое число (4 байта), которое увеличивается при каждом обращении к файлу, как при чтении, так и при записи. Это даёт возможность отследить количество операций с файлом и потенциальные изменения данных.
  
  \item \textbf{Количество записей} (\texttt{count}) --- целое число (4 байта), указывающее сколько структур ZNAK находится в данном файле после заголовка.
  
  \item \textbf{Контрольная сумма (CRC-32)} --- вычисляется по алгоритму CRC-32 для всех данных, следующих за заголовком. Она нужна для того, чтобы в любой момент можно было проверить целостность данных: если файл будет повреждён или модифицирован некорректно, пересчитанная контрольная сумма не совпадёт с записанной, и можно будет определить, что данные ненадёжны.
\end{itemize}

Редактирование исходного файла, содержащего как структуру данных о человеке, так и структуру заголовка базы данных, производилось в редакторе \texttt{nano}, что показано на скриншоте ниже:

\screenshot{Screenshot_2025-06-27_at_03.32.39.png}{Редактирование структуры заголовка ZNAK\_DB\_HEADER и структуры ZNAK в nano}

Таким образом, заголовок обеспечивает:
\begin{itemize}
  \item идентификацию формата файла с помощью сигнатуры;
  \item учёт количества операций чтения/записи через transaction\_id;
  \item хранение информации о количестве записей в базе;
  \item проверку целостности данных с помощью CRC-32.
\end{itemize}

\subsubsection*{Использование \texttt{uint32\_t} вместо \texttt{int}}

Для описания полей заголовка базы данных использовался \texttt{uint32\_t} из заголовочного файла \texttt{<stdint.h>}, а не привычный \texttt{int}. Это сделано по следующим причинам:

\begin{itemize}
  \item \textbf{Гарантированный размер:} 
  Тип \texttt{uint32\_t} представляет собой \textbf{беззнаковое целое ровно 4 байта (32 бита)} на всех платформах. В то время как \texttt{int} в языке C лишь гарантирует, что будет не менее 2 байт (обычно 4 байта, но это зависит от архитектуры и компилятора).

  \item \textbf{Переносимость бинарного формата:}
  Так как база данных сохраняется в бинарном формате, важно, чтобы структура файла выглядела одинаково на всех системах (например, x86, ARM). Использование \texttt{uint32\_t} позволяет гарантировать, что поля заголовка будут точно занимать 4 байта, а значит файл можно будет прочитать на любой платформе.

  \item \textbf{Отсутствие знака для идентификаторов и счётчиков:}
  Поля \texttt{transaction\_id}, \texttt{count} и \texttt{checksum} не могут быть отрицательными по своей природе. Использование беззнакового типа \texttt{uint32\_t} явно показывает, что эти значения не должны быть отрицательными, и исключает возможность их интерпретации как отрицательных чисел.
\end{itemize}

\subsubsection{Реализация программы с использованием ncurses для работы с бинарной базой данных}

В рамках данного задания была составлена программа на языке \texttt{C}, использующая библиотеку \texttt{ncurses} для визуализации работы с двоичным файлом базы данных. Программа включает:

\begin{itemize}
    \item интерфейс для ввода и отображения записей;
    \item хранение данных в бинарном файле со специальным заголовком;
    \item выполнение индивидуального задания --- поиск по знаку зодиака и году рождения;
    \item возможность добавления записей с обновлением заголовка.
\end{itemize}

\subsubsection*{Использование библиотеки \texttt{ncurses} и \texttt{zlib}}

При реализации программы использовались две важные внешние библиотеки:

\begin{itemize}
    \item \textbf{\texttt{ncurses}} — для организации псевдографического интерфейса в терминале;
    \item \textbf{\texttt{zlib}} — для вычисления контрольной суммы данных в формате CRC-32.
\end{itemize}

\subsubsection{Работа с библиотекой \texttt{ncurses}}

Библиотека \texttt{ncurses} предоставляет набор функций для работы с текстовым интерфейсом в терминале, включая управление выводом текста, перемещением курсора, очисткой экрана и считыванием пользовательского ввода без перехода на новую строку.

В программе использовались следующие функции:
\begin{itemize}
    \item \texttt{initscr()}, \texttt{endwin()} — инициализация и завершение работы с экраном;
    \item \texttt{cbreak()}, \texttt{noecho()}, \texttt{echo()} — настройка режима ввода (без ожидания Enter, а также включение/отключение отображения вводимых символов на экране; например, \texttt{noecho()} используется для того, чтобы не выводить вводимые пользователем символы непосредственно в терминале, а выводить их вручную через \texttt{mvprintw()});
    \item \texttt{setlocale(LC\_ALL, "ru\_RU.UTF-8")} — установка локали для корректного вывода и обработки кириллицы в интерфейсе (поддержка UTF-8 для псевдографики и русских символов);
    \item \texttt{clear()}, \texttt{move()}, \texttt{clrtoeol()} — очистка всего экрана или отдельных строк;
    \item \texttt{mvprintw()} — вывод форматированного текста в заданную позицию;
    \item \texttt{getnstr()}, \texttt{scanw()}, \texttt{getch()} — считывание строк, чисел и одиночных символов от пользователя;
    \item \texttt{getmaxyx()} — получение размеров терминала для реализации постраничного вывода.
\end{itemize}

Благодаря \texttt{ncurses} был реализован удобный интерфейс с полями ввода, сообщениями об ошибках и навигацией между страницами при отображении большого количества записей в базе данных.

\subsubsection{Использование библиотеки \texttt{zlib}}

Библиотека \texttt{zlib} использовалась для расчёта контрольной суммы всех данных, хранящихся в файле базы. Это позволяет в дальнейшем проверить целостность базы данных, так как любое повреждение файла изменит значение CRC-32.

Программа применяет следующие функции из \texttt{zlib.h}:
\begin{itemize}
    \item \texttt{crc32(0L, Z\_NULL, 0)} — инициализация значения контрольной суммы;
    \item \texttt{crc32(previous\_crc, (const Bytef*)data, size)} — вычисление CRC-32 для заданного блока данных.
\end{itemize}

Контрольная сумма записывается в заголовок базы данных и обновляется при каждом изменении данных, например, при добавлении новой записи.

\subsubsection{Исходные файлы программы}

Программа разбита на несколько модулей:

\begin{itemize}
    \item \texttt{znak.h} --- описание структур данных;
    \item \texttt{app.h} --- объявления функций работы с интерфейсом и файлами;
    \item \texttt{app.c} --- реализация функций интерфейса, работы с файлом и структуры базы;
    \item \texttt{main.c} --- точка входа и главное меню.
\end{itemize}

\subsubsection*{Файл \texttt{znak.h}}

\noindent
Заголовочный файл, где объявляются все поля структур. 

\subsubsection*{Файл \texttt{app.h}}

Заголовочный файл с объявлениями всех функций и необходимых констант --- В этом заголовочном файле задекларированы все функции программы, необходимые для работы с ncurses и двоичным файлом базы данных. Приведём краткое описание каждой функции:
\begin{itemize}
  \item \texttt{save\_db(ZNAK\_DB\_HEADER *header, ZNAK *arr, int count)} — сохраняет в бинарный файл заголовок и массив структур \texttt{ZNAK}, обновляя контрольную сумму и увеличивая номер транзакции при каждом сохранении.
  
  \item \texttt{find\_by\_year\_and\_zodiac(ZNAK\_DB\_HEADER *header, 
  ZNAK *arr, int count, const char *zodiac, int year)} — осуществляет поиск по базе данных по заданным году рождения и знаку зодиака. Отображает найденные результаты в виде таблицы на экране.
  
  \item \texttt{add\_record(ZNAK\_DB\_HEADER *header, ZNAK *arr, int *count)} — добавляет новую запись в массив, корректирует заголовок (увеличивает количество записей и номер транзакции), после чего сразу сохраняет базу на диск.
  
  \item \texttt{search\_records(ZNAK\_DB\_HEADER *header, ZNAK *arr, int count)} — интерфейс поиска: запрашивает у пользователя необходимые параметры (год и знак зодака), после чего вызывает функцию \break\texttt{find\_by\_year\_and\_zodiac} для выполнения поиска.
  
  \item \texttt{print\_db\_header(ZNAK\_DB\_HEADER *header)} — выводит информацию о заголовке базы данных: сигнатуру, номер транзакции, число записей и CRC-32 контрольную сумму.
  
  \item \texttt{db\_print\_interface(ZNAK\_DB\_HEADER *header, ZNAK *arr, int count)} — основной интерфейс для просмотра всех записей в базе с постраничным выводом и управлением навигацией через клавиши \texttt{n}, \texttt{p}, \texttt{q}.
  
  \item \texttt{print\_db(ZNAK\_DB\_HEADER *header, ZNAK *arr, int count)} — вспомогательная функция, используемая для табличного вывода всех записей без информации о заголовке.
  
  \item \texttt{error\_msg(const char *msg)} — показывает сообщение об ошибке в ncurses-окне и ждёт нажатия клавиши для продолжения работы.
  
  \item \texttt{clear\_except\_first\_line()} — очищает весь экран кроме первой строки, что позволяет аккуратно обновлять интерфейс, сохраняя статусную строку.
\end{itemize}

\subsubsection*{Файл \texttt{app.c}}

Ниже представлена реализация всех функций, обеспечивающих работу программы с использованием библиотеки \texttt{ncurses} и двоичного файла базы данных, на псевдокоде. Здесь сосредоточена вся прикладная логика, включая интерфейс ввода/вывода, работу с заголовком, чтение и запись файла, обработку ошибок и механизм постраничного отображения.

\subsubsection*{Вывод сообщений об ошибках}

Функция \texttt{error\_msg} предназначена для отображения сообщений об ошибках в интерфейсе \texttt{ncurses}. Она очищает экран, выводит переданное ей текстовое сообщение на первой строке и подсказку для пользователя на третьей строке о необходимости нажать любую клавишу для продолжения. После нажатия клавиши экран снова очищается, позволяя вернуться к нормальному взаимодействию программы.

\begin{lstlisting}[language=C, caption=Функция error\_msg]
функция error_msg(строка msg):
  очистить экран
  вывести строку msg на экран в позиции (1, 2)
  вывести строку в позиции (3, 2):
    "Нажмите любую клавишу для повторной попытки..."
  ожидать нажатия любой клавиши
  снова очистить экран
конец функции
\end{lstlisting}

\subsubsection*{Функция ввода записи}

Функция \texttt{input\_znak} обеспечивает пошаговый ввод пользователем данных для полей структуры \texttt{ZNAK}: фамилии и инициалов, знака зодиака и года рождения, с использованием интерфейса \texttt{ncurses}. Для строковых полей предусмотрены проверки на пустой ввод, а для года рождения — проверка диапазона от 1899 до 2025. Все данные сразу записываются в соответствующие поля структуры.

\begin{lstlisting}[language=C, caption=Функция input\_znak]
функция input_znak(указатель z):
  включить режим отображения вводимых символов (echo)

  повторять
    вывести строку "Фамилия и инициалы: " в позиции (2, 2)
    считать строку и сохранить в z.name
    если длина z.name > 0
      выйти из цикла
    иначе
      вызвать error_msg("Фамилия и инициалы не могут быть пустыми.")
  пока не будет введена непустая строка

  повторять
      вывести строку "Знак зодиака: " в позиции (3, 2)
      считать строку и сохранить в z.zodiac
      если длина z.zodiac > 0
        выйти из цикла
      иначе
        вызвать error_msg("Знак зодиака не может быть пустым.")
  пока не будет введена непустая строка

  повторять
    вывести строку "Год рождения: " в позиции (4, 2)
    считать целое число в переменную birth_year
    если birth_year в диапазоне [1899, 2025]
      присвоить z.birth_year <- birth_year
      выйти из цикла
    иначе
      вызвать error_msg("Год рождения должен быть в диапазоне 1899-2025.")
  пока не будет введён корректный год

  отключить режим отображения вводимых символов (noecho)
конец функции

\end{lstlisting}

\subsubsection*{Сохранение базы в файл}

Функция \texttt{save\_db} предназначена для сохранения текущего состояния базы данных в бинарный файл. Сначала открывается файл для записи в бинарном режиме. Затем обновляется поле \texttt{count} заголовка, инкрементируется \texttt{transaction\_id}, и вычисляется контрольная сумма CRC32 по всем данным массива структур для последующей проверки целостности. После этого в файл последовательно записываются заголовок и массив структур. В завершение файл закрывается.

\begin{lstlisting}[language=C, caption=Функция save\_db]
функция save_db(header, arr, count):
  открыть файл DB_FILENAME для записи в бинарном режиме и 
  присвоить дескриптор file
  если file == NULL тогда
    вывести сообщение об ошибке "Ошибка создания файла"
    завершить функцию

  header.count присвоить count
  увеличить header.transaction_id на 1

  вычислить CRC32 для пустого буфера и записать в header.checksum
  вычислить CRC32 для массива arr длиной sizeof(ZNAK) * count
    используя предыдущий header.checksum как начальное значение
    и обновить header.checksum

  записать структуру header в файл (fwrite)
  записать массив структур arr в файл (fwrite)
  закрыть файл (fclose)
конец функции

\end{lstlisting}

\subsubsection*{Добавление новой записи в базу данных}

Функция \texttt{add\_record} реализует режим добавления одной новой записи в массив структур. При вызове она очищает экран, выводит заголовок с сообщением о начале добавления записи, затем с помощью функции \texttt{input\_znak} запрашивает у пользователя данные для новой структуры. После успешного ввода увеличивает счётчик элементов массива и сразу сохраняет обновлённую базу данных в файл с помощью функции \texttt{save\_db}.

\begin{lstlisting}[language=C, caption=Функция add\_record]
функция add_record(header, arr, count):
  очистить экран
  вывести строку "Добавление новой записи:" в позицию (1, 2)

  вызвать функцию input_znak и передать ей элемент массива arr по 
  индексу *count
  увеличить *count на 1

  вызвать функцию save_db с параметрами header, arr и *count
конец функции
\end{lstlisting}

\subsubsection*{Вывод заголовка базы данных}
Данная функция отвечает за отображение основной служебной информации о бинарной базе данных на экран. Она выводит сигнатуру, номер транзакции, количество записей в базе и контрольную сумму CRC32, обеспечивающую целостность данных. После вывода всех полей заголовка пользователю предлагается нажать любую клавишу для продолжения.

\begin{lstlisting}[language=C, caption=Функция print\_db\_header]
функция print_db_header(header):
    очистить экран

    вывести строку "Заголовок базы данных:" в позицию (1, 2)
    вывести строку "Сигнатура: ..."         в позицию (2, 4),
    подставив header.signature

    вывести строку "Номер транзакции: ..."  в позицию (3, 4), 
    подставив header.transaction_id

    вывести строку "Количество записей: ..." в позицию (4, 4), 
    подставив header.count

    вывести строку "Контрольная сумма (CRC32): ..." в позицию (5, 4),
    подставив header.checksum

    вывести строку "Нажмите любую клавишу для выхода..." в позицию (20, 2)
    ожидать нажатие клавиши с помощью getch()
конец функции

\end{lstlisting}

\subsubsection*{Очистка экрана за исключением первой строки}
Функция \texttt{clear\_except\_first\_line} используется для очистки терминала с помощью библиотеки \texttt{ncurses}, оставляя нетронутой первую строку экрана. Это достигается за счёт прохода в цикле по строкам начиная со второй и вызова \texttt{clrtoeol} для стирания содержимого каждой строки. Таким образом обеспечивается возможность сохранения заголовка или другого важного сообщения в верхней части экрана при обновлении основного содержимого.

\begin{lstlisting}[language=C, caption=Функция clear\_except\_first\_line]
функция clear_except_first_line():
  получить размеры экрана (rows, cols) с помощью getmaxyx

  для i от 2 до rows:
    переместить курсор в начало строки i (позиция (i, 0))
    очистить строку до конца с помощью clrtoeol
конец функции
\end{lstlisting}

\subsubsection*{Интерфейс просмотра базы данных с постраничным выводом}
Функция \texttt{db\_print\_interface} организует интерфейс просмотра содержимого базы данных в виде таблицы с постраничной навигацией. С помощью возможностей библиотеки \texttt{ncurses} она отрисовывает заголовки столбцов («№», «Фамилия и инициалы», «Знак зодиака», «Год») и строки таблицы, где каждая строка соответствует одной записи структуры \texttt{ZNAK}. Вывод делится на страницы, количество записей на странице зависит от размеров текущего окна терминала. Пользователь может листать данные с помощью клавиш \texttt{n} (следующая страница) и \texttt{p} (предыдущая страница), либо выйти, нажав \texttt{q}.

\begin{lstlisting}[language=C, caption=Функция db\_print\_interface]
функция db_print_interface(header, arr, count):
  получить размеры экрана (rows, cols) с помощью getmaxyx

  lines_per_page := rows - 10
  start := 0

  пока start < count:
    очистить все строки, кроме первой с помощью clear_except_first_line

    вывести заголовок таблицы на экран:
      строка 2: "№  Фамилия и инициалы  Знак зодиака  Год"
    нарисовать горизонтальную линию в строке 3

    row := 4
    для i от start до min(count, start + lines_per_page) - 1:
      вывести запись с номером (i+1), 
      фамилией, знаком зодиака и годом рождения в строку row
      row := row + 1

    вывести в нижнюю строку (rows - 2):
      "Страница X/Y. Нажмите 'n' для следующей, 
'p' для предыдущей, 'q' для выхода."

    считать клавишу ch
    если ch == 'q' или ch == 'Q':
      выйти из цикла
    иначе если ch == 'n' или ch == 'N':
      start := start + lines_per_page
    иначе если ch == 'p' или ch == 'P' и start - lines_per_page >= 0:
      start := start - lines_per_page
    иначе:
      выйти из цикла
конец функции

\end{lstlisting}

\subsubsection*{Вывод содержимого базы данных}

Функция \texttt{print\_db} используется для вывода всех записей базы данных на экран. Сначала она очищает экран и вызывает \texttt{save\_db} для актуализации заголовка и пересчёта контрольной суммы. Затем выводит заголовок с сообщением \texttt{"Содержимое базы данных:"} и передаёт управление функции \texttt{db\_print\_interface}, которая обеспечивает постраничную навигацию и форматированный вывод записей.

\begin{lstlisting}[language=C, caption=Функция print\_db]
функция print_db(header, arr, count):
  очистить весь экран

  вызвать функцию save_db(header, arr, count)
  // сохраняет текущее состояние базы данных в файл
  // обновляет номер транзакции и контрольную сумму

  вывести строку в позицию (1,2):
    "Содержимое базы данных:"

  вызвать функцию db_print_interface(header, arr, count)
  // запускает постраничный интерфейс просмотра записей

конец функции
\end{lstlisting}

\subsubsection*{Поиск по знаку зодиака и году}

Функция \texttt{find\_by\_year\_and\_zodiac} выполняет поиск записей в базе данных по указанному знаку зодиака и году рождения. Сначала она вызывает \texttt{save\_db}, чтобы обновить заголовок и пересчитать контрольную сумму базы. Затем формирует временный массив найденных записей, проходя по всем данным и сравнивая значения. Если совпадения есть, вызывает \texttt{db\_print\_interface} для постраничного вывода результатов. Если совпадений не найдено, выводит соответствующее сообщение и ждёт нажатия клавиши для возврата в меню.

\begin{lstlisting}[language=C, caption=Функция find\_by\_year\_and\_zodiac]
функция find_by_year_and_zodiac(header, arr, count, zodiac, year):
  вызвать save_db(header, arr, count)
  // сохраняет актуальное состояние базы

  found := 0
  создать пустой массив found_arr размером count

  для i от 0 до count - 1:
    если arr[i].birth_year == year и arr[i].zodiac == zodiac:
      found_arr[found] := arr[i]
      found := found + 1

  очистить весь экран
  вывести строку на (1,2):
    "Результаты поиска по знаку 'zodiac' и году year:"

  если found > 0:
    вызвать db_print_interface(header, found_arr, found)
    // покажет найденные записи в интерфейсе
  иначе:
    вывести строку на (5,4):
      "Совпадений не найдено."
    вывести строку на (20,2):
      "Нажмите любую клавишу для выхода..."
    ожидать нажатия клавиши

конец функции

\end{lstlisting}
\subsubsection*{Запрос параметров для поиска}

Функция \texttt{search\_records} отвечает за интерфейс ввода пользователем параметров поиска. Она очищает экран, запрашивает у пользователя знак зодиака и год рождения с помощью \texttt{getnstr} и \texttt{scanw}. После этого передаёт введённые данные в функцию \break\texttt{find\_by\_year\_and\_zodiac}, которая непосредственно выполняет поиск и выводит результаты.

\begin{lstlisting}[language=C, caption=Функция search\_records]
функция search_records(header, arr, count):
  создать строку search_zodiac
  создать целое search_year

  очистить весь экран
  вывести строку на (1,2):
      "Введите знак зодиака: "
  включить отображение ввода
  считать строку в search_zodiac
  отключить отображение ввода

  вывести строку на (2,2):
      "Введите год рождения: "
  включить отображение ввода
  считать число в search_year
  отключить отображение ввода

  вызвать find_by_year_and_zodiac(header, arr, count, search_zodiac, search_year)
  // выполняет поиск и выводит результаты через интерфейс

конец функции
\end{lstlisting}

\subsubsection*{Файл \texttt{main.c}}

Главная управляющая функция программы расположена в файле \texttt{main.c}. 
Здесь выполняется инициализация терминала через библиотеку \texttt{ncurses}, настройка локали для поддержки кириллицы и псевдографики, а также реализован основной цикл взаимодействия с пользователем. 
Программа начинает свою работу с попытки открыть бинарный файл базы данных. 
Если файл отсутствует, пользователю предлагается ввести количество записей для создания новой базы, после чего последовательно вводятся данные о людях (фамилия и инициалы, знак зодиака и год рождения), которые сразу же сохраняются в файл. 
При наличии файла база загружается в оперативную память, а пользователь сразу переходит к главному меню программы.

Основной цикл предоставляет следующие возможности:
\begin{itemize}
    \item Просмотр заголовка базы данных (сигнатура, номер транзакции, количество записей и контрольная сумма CRC32).
    \item Просмотр всех записей базы данных с постраничной навигацией.
    \item Поиск записей по году рождения и знаку зодиака с последующим выводом результатов.
    \item Добавление новой записи в базу данных.
    \item Выход из программы.
\end{itemize}

Завершая работу, программа корректно завершает режим работы \texttt{ncurses} через \texttt{endwin()}, что восстанавливает стандартное состояние терминала.

\vspace{0.2cm}

Для наглядности интерфейса приведены следующие скриншоты, иллюстрирующие работу программы:

\screenshot{Screenshot_2025-07-01_at_13.45.33.png}{Главное меню программы с выбором действия. Пользователю предлагаются опции для просмотра заголовка базы, просмотра всех записей, поиска по критериям, добавления записи или выхода из программы.}
\screenshot{Screenshot_2025-07-01_at_13.46.15.png}{Сообщение о том, что файл базы данных не найден. В этом случае пользователь должен указать количество записей для создания новой базы, после чего выполняется последовательный ввод данных.}

\subsubsection*{Замечание о сборке, тестировании и исследовании зависимостей}

Сборочные файлы, тестирующие программы, а также все эксперименты по запуску и исследованию работы разработанной программы находятся в отдельном разделе \textbf{«Результаты работы и эксперименты»}.

\vspace{0.3cm}

В данном разделе будут приведены:
\begin{itemize}
    \item подробное описание сборки программы с использованием \texttt{CMakeLists.txt};
    \item результаты тестирования работы приложения с различными наборами данных;
    \item исследование разделяемых библиотек в полученной программе с помощью утилиты \texttt{ldd};
    \item построение рекурсивного дерева зависимостей на основе результатов работы \texttt{ldd}.
\end{itemize}