\section{Математическое описание алгоритма Minimax с альфа-бета отсечением}
\subsection{Рекурсивная функция Minimax}

Пусть $S$~— множество всех возможных состояний игры (конфигураций поля).  
В каждом состоянии $s \in S$ определено множество допустимых ходов $A(s)$.  
Пусть $f(s)$~— функция оценки, отображающая позицию $s$ в действительное число. Значение $f(s)$ интерпретируется так, что чем больше $f(s)$, тем лучше позиция для игрока $X$ (максимизатора).

\vspace{1em}


\[
\mathrm{Minimax}(s, d, \alpha, \beta, p) = 
\begin{cases}
f(s), & \text{если } d = 0\\[2ex]
\displaystyle\max\limits_{a \in A(s)} \mathrm{Minimax}(s_a, d-1, \alpha, \beta, 0), & \text{если } p=1 \\[2ex]
\displaystyle\min\limits_{a \in A(s)} \mathrm{Minimax}(s_a, d-1, \alpha, \beta, 1), & \text{если } p=0 \\
\end{cases}
\]

\vspace{1em}

Здесь:
\begin{itemize}
    \item $s$ — текущее состояние,
    \item $d$ — оставшаяся глубина рекурсии,
    \item $\alpha$ — лучшая (наибольшая) найденная оценка для максимизатора ($X$) на пути к корню дерева,
    \item $\beta$ — лучшая (наименьшая) найденная оценка для минимизатора ($O$) на пути к корню дерева,
    \item $p$ — индикатор хода: $p=1$ для $X$ (максимизатор), $p=0$ для $O$ (минимизатор),
    \item $s_a$ — новое состояние после применения хода $a$ к $s$.
\end{itemize}

\vspace{1em}

\subsubsection*{Пошаговое описание работы алгоритма}

\begin{enumerate}
    \item Если достигнута максимальная глубина $d = 0$ или $s$ — терминальная позиция (например, кто-то выиграл или ничья), возвращается значение функции оценки $f(s)$.

    \item Если ход максимизатора ($p=1$):
    \begin{itemize}
        \item Инициализируется $v = -\infty$.
        \item Для каждого допустимого хода $a \in A(s)$ вычисляется $\mathrm{Minimax}(s_a, d-1, \alpha, \beta, 0)$.
        \item Значение $v$ обновляется как максимум из текущего $v$ и результата рекурсивного вызова.
        \item Обновляется значение $\alpha = \max(\alpha, v)$.
        \item Если $\alpha \geq \beta$, дальнейшие ходы не рассматриваются (альфа-бета отсечение).
        \item После перебора всех ходов возвращается $v$.
    \end{itemize}
    
    \item Если ход минимизатора ($p=0$):
    \begin{itemize}
        \item Инициализируется $v = +\infty$.
        \item Для каждого допустимого хода $a \in A(s)$ вычисляется $\mathrm{Minimax}(s_a, d-1, \alpha, \beta, 1)$.
        \item Значение $v$ обновляется как минимум из текущего $v$ и результата рекурсивного вызова.
        \item Обновляется значение $\beta = \min(\beta, v)$.
        \item Если $\beta \leq \alpha$, дальнейшие ходы не рассматриваются (альфа-бета отсечение).
        \item После перебора всех ходов возвращается $v$.
    \end{itemize}
\end{enumerate}

\vspace{1ex}

\textbf{Алгоритм в псевдокоде:}

\begin{verbatim}
Функция Minimax(s, d, alpha, beta, maximizing):
    если d == 0 или конец игры:
        вернуть f(s)
    если maximizing:
        лучшая = -inf
        для каждого хода a:
            v = Minimax(s_a, d-1, alpha, beta, False)
            если v > лучшая: лучшая = v
            если v > alpha: alpha = v
            если beta <= alpha: break
        вернуть лучшая
    иначе:
        лучшая = +inf
        для каждого хода a:
            v = Minimax(s_a, d-1, alpha, beta, True)
            если v < лучшая: лучшая = v
            если v < beta: beta = v
            если beta <= alpha: break
        вернуть лучшая
\end{verbatim}

\textit{В результате алгоритм Minimax находит оптимальный ход для текущего состояния поля с учётом того, что соперник всегда будет выбирать самый опасный для нас ответ.}
